#!/usr/bin/env python

"""
Creates a Master on the MQTT Protocol to communicate with other Client entities

Master requests information that is generated by its Client's when is executed.
The communication between Master and its Clients is done through MQTT Protocol with InfluxDB
"""

# ----------------------------------------

# Standard Library
import time
import sys
import os

# 3rd Party Packages
import paho.mqtt.client as mqtt
from influxdb import InfluxDBClient

# Local Source
from utils import *

__author__ = "António Pereira"
__email__ = "antonio_m_sp@hotmail.com"
__status__ = "Development"


# ----------------------------------------


def on_connect(client, userdata, flags, rc):
    """
    MQTT connect protocol

    Error Code, RC:
    0: Connection successful
    1: Connection refused – incorrect protocol version
    2: Connection refused – invalid client identifier
    3: Connection refused – server unavailable
    4: Connection refused – bad username or password
    5: Connection refused – not authorised
    6-255: Currently unused.
    """

    if rc != 0:
        logging.info("Master - Error connecting to Broker. Return Code: ", rc)
        client.reconnect()
    else:
        logging.info("Master - Successfully connected to Broker.")
        client.subscribe("topic/simulation/clients/#", qos=1)


def on_message(client, userdata, message):
    """
    Receives the messages that are published through the broker
    """

    decoded_message = str(message.payload.decode("utf-8"))

    if decoded_message == "WORKING":
        pass
    else:
        mqtt_protocol_print(message)

    if decoded_message == "ALL_INFORMATION_SENT":
        global RECEIVED_ALL_DATA_FROM_CLIENT_TOTAL
        RECEIVED_ALL_DATA_FROM_CLIENT_TOTAL += 1

        if RECEIVED_ALL_DATA_FROM_CLIENT_TOTAL == int(CLIENT_SIZE):
            global ALL_DATA_RECEIVED
            ALL_DATA_RECEIVED = True

            req_end_time = time.perf_counter()
            master_req_time = req_end_time - req_start_time

            logging.info("Since Master did Request till all data arrived it took: {%.5f} seconds\n", master_req_time)
            client.publish(MASTER_TOPIC_NAME, "REQUEST_FINISHED", qos=0, retain=False)

        try:
            client_name = message.topic.split('/')
            client.publish(MASTER_TOPIC_NAME, "DATA_RECEIVED_FROM_" + client_name[3])
        except ValueError:
            logging.info("Error splitting topic string in " + client_name[3])


def mqtt_init(tmp_master):
    """
    Connects to Broker and initializes protocols
    """

    # broker_address = "broker.hivemq.com"
    broker_address = "localhost"
    broker_port = 1883

    tmp_master.on_connect = on_connect
    tmp_master.on_message = on_message

    try:
        tmp_master.connect(broker_address, port=broker_port)
    except ConnectionError:
        logging.info("Error connecting to Broker: %s, on Port: %s" % (broker_address, broker_port))
        tmp_master.reconnect()


def clear_masterDB_data():
    """
    Clears every value from MasterDB.
    """

    db.switch_database(MASTER_DB_NAME)
    # db.drop_database(MASTER_DB_NAME)

    query = "DROP SERIES FROM weldingEvents;"
    logging.debug("Cleaning Master DB...")
    db.query(query)
    logging.debug("Finished cleaning DB...")


def mqtt_terminate(tmp_master):
    """
    Stops MQTT loop and disconnects client
    """

    tmp_master.loop_stop()
    tmp_master.disconnect()


def get_masterDB_data():
    """
    Queries master's DB to print the total number of
    welding_value that reached master's DB from its clients.
    """

    db.switch_database(MASTER_DB_NAME)

    try:
        new_data = db.query("SELECT count(welding_value) FROM weldingEvents;")
        all_events = list(new_data.get_points(measurement='weldingEvents'))
        logging.info('Number of Welding Values in MasterDB: {' + str(all_events[0]['count']) + '}')
    except ValueError:
        logging.info("Error counting number of total welding values reached Master DB.")


def init_logging_config():
    logging.root.handlers = []

    if 'DEBUG_MODE' in sys.argv:
        logging.basicConfig(filename=SOLUTION_PATH + '\\' + 'master.log', format='%(asctime)s : %(levelname)s : %(message)s',
                            level=logging.DEBUG, filemode='a')
    else:
        logging.basicConfig(filename=SOLUTION_PATH + '\\' + 'master.log', format='%(asctime)s : %(levelname)s : %(message)s',
                            level=logging.INFO, filemode='a')

    # logging.basicConfig(format=thread_format, level=logging.INFO, datefmt="%H:%M:%S")

    # set up logging to console
    console = logging.StreamHandler()
    console.setLevel(logging.INFO)

    # set a format which is simpler for console use
    formatter = logging.Formatter('%(asctime)s : ' + SOLUTION_PATH + ' : %(levelname)s : %(message)s')
    console.setFormatter(formatter)
    logging.getLogger("").addHandler(console)


if __name__ == "__main__":

    # Arguments
    CLIENT_SIZE = sys.argv[1]
    SOLUTION_PATH = sys.argv[2]

    # Global Variables
    ALL_DATA_RECEIVED = False
    RECEIVED_ALL_DATA_FROM_CLIENT_TOTAL = 0
    MASTER_DB_NAME = 'master_db'
    MASTER_TOPIC_NAME = 'topic/simulation/master'

    # InfluxDB
    db = InfluxDBClient('localhost', 8086, 'root', 'root', MASTER_DB_NAME)
    db.create_database(MASTER_DB_NAME)
    # clear_masterDB_data()

    # Logging Configuration
    init_logging_config()

    # Broker
    master = mqtt.Client()
    mqtt_init(master)

    req_start_time = time.perf_counter()
    master.publish(MASTER_TOPIC_NAME, "GET_INFORMATION", qos=0, retain=False)

    master.loop_start()

    while not ALL_DATA_RECEIVED:
        pass

    get_masterDB_data()
    mqtt_terminate(master)
    quit()
